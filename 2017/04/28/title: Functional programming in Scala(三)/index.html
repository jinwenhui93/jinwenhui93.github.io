<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta name="baidu-site-verification" content="8OKYZpG0HX" />
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Functional programming,Scala," />





  <link rel="alternate" href="/atom.xml" title="SweatBuffer`s Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="#Scala/Chapter3#
Chapter3 Functional data structures (函数式数据结构)我们讲函数型程序并不更新 变量或者修改 可变的数据结构 那我们会提出疑问：

在函数式编程里面 什么样的(what sort of )数据结构 我们可以用
我们如何在 Scala 中定义他们
我们如何操作(operate)这些数据结构

在这章我们将会学习函数式 数据结构 (">
<meta property="og:type" content="article">
<meta property="og:title" content="Functional programming in Scala(三)">
<meta property="og:url" content="http://www.sweatbuffer.com/2017/04/28/title: Functional programming in Scala(三)/index.html">
<meta property="og:site_name" content="SweatBuffer`s Blog">
<meta property="og:description" content="#Scala/Chapter3#
Chapter3 Functional data structures (函数式数据结构)我们讲函数型程序并不更新 变量或者修改 可变的数据结构 那我们会提出疑问：

在函数式编程里面 什么样的(what sort of )数据结构 我们可以用
我们如何在 Scala 中定义他们
我们如何操作(operate)这些数据结构

在这章我们将会学习函数式 数据结构 (">
<meta property="og:updated_time" content="2017-04-28T13:15:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Functional programming in Scala(三)">
<meta name="twitter:description" content="#Scala/Chapter3#
Chapter3 Functional data structures (函数式数据结构)我们讲函数型程序并不更新 变量或者修改 可变的数据结构 那我们会提出疑问：

在函数式编程里面 什么样的(what sort of )数据结构 我们可以用
我们如何在 Scala 中定义他们
我们如何操作(operate)这些数据结构

在这章我们将会学习函数式 数据结构 (">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.sweatbuffer.com/2017/04/28/title: Functional programming in Scala(三)/"/>





  <title> Functional programming in Scala(三) | SweatBuffer`s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SweatBuffer`s Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">发酵的奶酪</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.sweatbuffer.com/2017/04/28/title: Functional programming in Scala(三)/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="SweatBuffer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="SweatBuffer`s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="SweatBuffer`s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Functional programming in Scala(三)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-28T21:43:24+09:00">
                2017-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Functional-programming-Scala/" itemprop="url" rel="index">
                    <span itemprop="name">Functional programming,Scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/28/title: Functional programming in Scala(三)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/28/title: Functional programming in Scala(三)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
            <span>&nbsp; | &nbsp;
            <span id="busuanzi_value_page_pv" ></span>次阅读
            </span>    
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#Scala/Chapter3#</p>
<h1 id="Chapter3-Functional-data-structures-函数式数据结构"><a href="#Chapter3-Functional-data-structures-函数式数据结构" class="headerlink" title="Chapter3 Functional data structures (函数式数据结构)"></a>Chapter3 Functional data structures (函数式数据结构)</h1><p>我们讲函数型程序并不<strong>更新 变量</strong>或者<strong>修改 可变的数据结构</strong> 那我们会提出疑问：</p>
<ol>
<li>在函数式编程里面 什么样的(what sort of )数据结构 我们可以用</li>
<li>我们如何在 Scala 中定义他们</li>
<li>我们如何操作(operate)这些数据结构</li>
</ol>
<p>在这章我们将会学习<strong>函数式 数据结构</strong> (<strong>functional data structures</strong> )的概念和如何使用他们。我们将借此机会介绍 在函数式编程里 数据类型(data type)是如何定义的，学习 <strong>模式匹配</strong>(<strong>pattern matching</strong>)相关的技术，练习编写和归纳 <strong>纯粹的函数</strong>(<strong>pure functions</strong>)。</p>
<h2 id="3-1-Defining-functional-data-structures-定义-函数式数据结构"><a href="#3-1-Defining-functional-data-structures-定义-函数式数据结构" class="headerlink" title="3.1 Defining functional data structures (定义 函数式数据结构)"></a>3.1 Defining functional data structures (定义 函数式数据结构)</h2><p>一个函数式数据结构只有在使用 纯粹的函数(<strong>pure functions</strong>)的时候使用。记住，一个纯粹函数必须不能直接改变data 或者 执行其他的 <strong>side effect</strong> (附加的东西 比如在一个买咖啡的函数里面，执行连接信用卡server的代码 这个就属于 side effect)。<br><strong>所以 函数式数据结构定义的内容是不可改变的</strong>。<br>例如：在Scala里的 List() 和 Nil 就是不可变的。在进行List 操作的时候 比如 计算  3 + 4 我们并不改变 3或者4本身 而是新生成一个变量 7. 两个input 都不改变。连接两个链表操作也是啊， append 链表A 和 链表B 他并不改变输入本身，而是新建立一个链表。<br>这是不是意味着我们做了很多额外的复制工作呢？其实不是的。首先我们看一下最普遍的函数数据结构，单链表 (Singly linked list)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">A</span>]</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">head: <span class="type">A</span>,tail: <span class="type">List</span>[<span class="type">A</span>]</span>)<span class="keyword">extends</span> <span class="title">List</span>[<span class="type">A</span>]</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">Nothing</span>]</span></div></pre></td></tr></table></figure>
<p><strong>sealed trait</strong> 是什么意思？<br><strong>trait</strong> 是一个抽象的接口(abstract interface) 可以选择性的包含一些方法的实现。在这里声明一个 <strong>trait</strong> 叫做 <strong>List</strong> ，不含有任何方法。添加<strong>sealed</strong>在前面意味着 这个 trait 的所有的实现必须在这个文件里面声明。<br>这里面有两种实现 或者说 List 的 数据 构造(data constructors)  来代表 List 可以使用的的两种形式。<br>一个List 可以为空，由 Nil 来指示，不为空的时候由 Cons来指示。一个不为空的List 由 | Head | Tail | 来组成。Tail 是 表示剩余元素的一个List 。<br>正因为函数可以是多态的，数据类型也一样，通过添加 类型参数(type parameter) [+A]  在sealed trait List 后面 然后在 Cons data constructor 里面使用这个 A 类型的参数，我们声明 这个 List 数据类型为多态的意味着 我们可以使用相同的定义 对一个 Int 元素 List[Int], Double 元素(List[Double]), String 元素(List[String]) 等等。“<strong>+</strong>” 意味着 类型参数 A 是 协变的，共变的(<strong>Covariant</strong>). 意味着 A 是一个List 的 共变，积极参数。（个人理解这句话的意思是：List 和 参数 A 是共同， A 是Int，List 类型就是 List[Int], 就怎么说呢 他俩一起变化，一起等价这种概念吧)</p>
<p>例如：<br><strong>Covariant</strong>: For all types x and y .</p>
<ul>
<li>if x &lt;: y, then List[x] &lt;: List[y] (&lt;:表示继承关系中的辈分高低)</li>
<li>If not annotated, parameter is invariant, meaning there is no subtype relationship List[x] and List[y]<br>就是如果 参数有父子关系的话，那么List 也具有 父子关系。(个人理解)</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ex1:<span class="type">List</span>[<span class="type">Double</span>] = <span class="type">Nil</span></div><div class="line"><span class="keyword">val</span> ex2:<span class="type">List</span>[<span class="type">Int</span>] = <span class="type">Cons</span>(<span class="number">1</span>,<span class="type">Nil</span>)</div><div class="line"><span class="keyword">val</span> ex3:<span class="type">List</span>[<span class="type">String</span>] = <span class="type">Cons</span>(<span class="string">"a"</span>, <span class="type">Cons</span>(<span class="string">"b"</span>,<span class="type">Nil</span>))</div></pre></td></tr></table></figure>
<p>一个数据构造函数声明 给我们一个方法去构造 这个数据类型的形式。例如：上面的三个👆式子。<br>Case object Nil 让我们写一个<code>Nil</code>去构造一个空的List ， case class Cons 让我们写 <code>Cons(“a”, Cons(“b”, Nil))</code> 去构造一个任意长度的单链表。<br>注意：因为List 是参数化的，A, 对A，这里有 可以被不同的类型实例化的多态函数。 ex2 实例化 A 类型的参数到 <strong>Int</strong> ， ex3 实例化为 <strong>String</strong>，ex1 很有趣，Nil 是被实例化为 List[Double]类型了，这是被允许的，因为空的List 没有元素，可以被看做任意类型。<br>“老艺术家”说 Nil 定义的时候是 继承了 List[Nothing] 这是所有List 类的 最小辈分的一种，可以是任何类的子类。顺便拓展一下 ：<br>继承关系： Animal类  &lt;- Cat类 &lt;- Kitty类                ————————<br>Animal<br>————————<br>^<br>————————<br>Cat<br>————————<br>^<br>————————<br>Kitty<br>————————<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</div><div class="line">	<span class="type">Cat</span> foo(<span class="type">Cat</span> c)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</div><div class="line">	<span class="type">Kitty</span>      	   (<span class="type">Kitty</span> c)</div><div class="line">		   + foo +</div><div class="line">	<span class="type">Animal</span>		   (<span class="type">Animal</span> c)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回类型问题和参数类型的问题：<br>先说 <strong>~返回类型~</strong> 哦，<br>亲子关系： Animal类  &lt;- Cat类 &lt;- Kitty类 ，<br>那么在内存里的空间状态是：[ <em> </em> ] &lt; [ <em> </em> <em> ] &lt; [ </em> <em> </em> <em> </em> ] 顺序是相反的，因为子类要保证父母能有的成员变量，成员方法自己都持有，但是子类持有的 变量和方法，父母类就不一定有了。所以返回的时候你要返回Kitty类型，ok，没有问题，因为他的空间包含了Cat 所需要的空间大小，但是返回 Animal 惨了，Animal的比 Cat 小哎，调用的时候 会有问题。换个人性化思维思考：父类里面的foo是猫，那么子类的 foo 只可能是 猫这个大类里面的小类别：波斯猫，kitty猫，你返回一个爬行哺乳动物就不对了。<br><strong>~参数类型~</strong> ：参数是用来做 operation 的，那么父类的参数是Cat ，显然他需要用猫的某些技能或者特性，比如喵喵叫，舔自己，闻屁股，那么Bar 中的参数必然也要最起码满足这个要求，但是不许超出这个范围，你input 一个kitty特有的粉红色是猫这个类不具有的性质，那么就有问题了。<br>要保证在这里调用的东西，父类方法里面最起码都有。</p>
<p>综上所述：返回类型可以使本身，或者子类 往下走；参数类型可以是自己或者父类 往上走。好像延展的有点多了。。。<br>所以~~ Nil 是 List[ Nothing ], 在 Scala 里面，Nothing 是所有类型的子类，那么Nil 就是所有 List 类型的子类，所以 Nil 可以赋给任何类型的List 值。</p>
<p>添加补充一下：</p>
<h3 id="Scala-Convariance-and-Contravariance-逆变与协变"><a href="#Scala-Convariance-and-Contravariance-逆变与协变" class="headerlink" title="Scala Convariance and Contravariance(逆变与协变)"></a>Scala Convariance and Contravariance(逆变与协变)</h3><p>Function范式里面定义了函数的”入参”和”出参” 分别是“逆变”(Contravariance)和”协变”(Convariance)的。</p>
<p>所以A=&gt;B这样的函数类型，也可以有继承关系的。<br>我们做个测试，先简单些，只看<strong>出参类型</strong>的(协变容易理解些)，A=&gt;B和A=&gt;C两个函数类型;<br>如果C extends B 则A=&gt;C 是 A=&gt;B的子类型<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>; <span class="class"><span class="keyword">class</span> <span class="title">Cats</span></span>; <span class="class"><span class="keyword">class</span> <span class="title">Kitty</span> <span class="keyword">extends</span> <span class="title">Cats</span></span></div><div class="line"> </div><div class="line"><span class="comment">//定义A=&gt;C类型的函数</span></div><div class="line">scala&gt; <span class="keyword">val</span> t2 = (p:<span class="type">A</span>)=&gt;<span class="keyword">new</span> <span class="type">Kitty</span></div><div class="line"> </div><div class="line"><span class="comment">//可以把 A=&gt;C类型的函数赋值给 A=&gt;B类型的</span></div><div class="line">scala&gt; <span class="keyword">val</span> t3:<span class="type">A</span>=&gt;<span class="type">Cats</span> = t2</div><div class="line"> </div><div class="line"><span class="comment">//或直接把t2造型为 A=&gt;Cats</span></div><div class="line">scala&gt; t2.asInstanceOf[<span class="type">A</span>=&gt;<span class="type">Cats</span>]</div></pre></td></tr></table></figure></p>
<p>再看看<strong>入参类型</strong>，这个是逆变，继承关系正好相反。<br>假设: B=&gt;A, C=&gt;A 如果 C extends B 则 B=&gt;A 是 C=&gt;A 的子类型<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">R</span></span>; <span class="class"><span class="keyword">class</span> <span class="title">Cats</span></span>; <span class="class"><span class="keyword">class</span> <span class="title">Kitty</span> <span class="keyword">extends</span> <span class="title">Cats</span>  </span></div><div class="line"> </div><div class="line"><span class="comment">//定义Cats=&gt;R类型的函数</span></div><div class="line">scala&gt; <span class="keyword">val</span> f1 = (x:<span class="type">Cats</span>)=&gt;<span class="keyword">new</span> <span class="type">R</span></div><div class="line"> </div><div class="line"><span class="comment">//把Cats=&gt;R类型的函数赋值给 Kitty=&gt;R 类型的</span></div><div class="line">scala&gt; <span class="keyword">val</span> f2:<span class="type">Kitty</span> =&gt;<span class="type">R</span> = f1</div><div class="line"> </div><div class="line"><span class="comment">//或直接造型</span></div><div class="line">scala&gt; f1.asInstanceOf[<span class="type">Kitty</span>=&gt;<span class="type">R</span>]</div></pre></td></tr></table></figure></p>
<p>协变和逆变的场景与java泛型的”PECS原则”一致</p>
<p>PECS 是Joshua Bloch在《Effictive Java》里提出的一个原则。<br>当参数(容器)是一个生产者(producer)提供元素给你的代码来用(即容器只读),那么容器的泛型应该使用:<br><code>Collection&lt; ? extends T &gt;</code></p>
<p>当参数(容器)作为一个消费者(consumer)来消费你提供的数据(即容器可写),那么容器的泛型应该使用:<br><code>Collection&lt; ? super T &gt;</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">List</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]):<span class="type">Int</span> = ???</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(xs:<span class="type">List</span>[<span class="type">Double</span>]):<span class="type">Double</span> = ??</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>](as: <span class="type">A</span>*):<span class="type">List</span>[<span class="type">A</span>] = ?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个 数据构造器 同样引入 模式(pattern) 可以被用于 模式设计，就像在 sum 和 product 方法里一样</p>
<hr>
<h2 id="3-2-Pattern-matching-模式匹配"><a href="#3-2-Pattern-matching-模式匹配" class="headerlink" title="3.2 Pattern matching (模式匹配)"></a>3.2 Pattern matching (模式匹配)</h2><p>仔细的看 <strong>sum</strong> 和 <strong>product</strong> 的细节，我们放入了 object List 里面，有时候叫做 Object List 的 <strong>伴生对象</strong> (<strong>companion object</strong>)。</p>
<p><strong>伴生对象</strong>： 我们除了声明 ~数据类型~ 和 ~数据构造函数~ 之外常常声明 ~伴生对象~。 这是和数据类型有着一样的名字(这里是 List ),我们放入多种方便的函数 到对象中 为了创建或者使用这种数据类型的值。(这句话怪哦)<br>例如我们希望一个函数 <code>def fill[A](n:Int, a:A):List[A]</code> 创建 一个List 里面有n个元素a，这个List 的伴生对象将会是一个好的地方。伴生对象不仅是在Scala里面的一种约定(Convention)。我们可以叫 这个 模块 Foo 如果我们希望，但是叫他 List 会很明确的显示 这个模块包含着关于 list 的一些方法。</p>
<p>下面的定义都使用了 模式匹配(pattern matching):<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(ints: <span class="type">List</span>[<span class="type">Int</span>]):<span class="type">Int</span> = ints <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span></div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(x,xs) =&gt; x + sum(xs)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(ds: <span class="type">List</span>[<span class="type">Double</span>]): <span class="type">Double</span> = ds <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">1.0</span></div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(<span class="number">0.0</span>, _) =&gt; <span class="number">0.0</span></div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(x,xs) =&gt; x * product(xs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些是递归定义，写方法的时候 Scala等函数式编程很喜欢递归。Pattern matching 有点像 switch 文， 首先有一个 expression 像 ds 在 match 前面，然后每个 case 会有各自相应的 pattern 像 Cons(x,xs) 然后 =&gt; 后面跟的是 结果。如果 target expression 满足某个case 里的 pattern 那么就实现pattern 对应的 结果。如果 有 满足多个case 的情况，选择最先匹配到的 pattern 来执行。<br>看一下更多的例子：</p>
<ul>
<li><code>List(1,2,3) match {case _ =&gt; 42}</code> 输出值为42，因为 ‘_’ 意味着无论是什么值，都可以匹配，任意一种情况都会执行这个pattern。</li>
<li><code>List(1,2,3) match {case Cons(h,_) =&gt; h}</code> 这种情况会输出列表中的头，也就是说1，这种模式把List 中的 Head 和 Tail 分开了，值得我们学习哦。</li>
<li><code>List(1,2,3) match {case Cons(_,t) =&gt; t}</code> 这段代码则是不管Head 是什么，我只要Tail 并且输出Tail 所以输出结果是 List(2,3)</li>
<li><code>List(1,2,3) match {case Nil =&gt; 42}</code>会导致 <strong>MatchError</strong>错误发生。</li>
</ul>
<p>List(1,2,3) = Cons(1,Cons(2,Cons(3, Nil )))</p>
<p>那是什么决定了是否一个 pattern 匹配一个 expression 呢？ 一个 pattern 可能包含 <strong>~常量~</strong> 像 3 或者 “hi” ; <strong>~变量~</strong> 像 <strong>x</strong> 和 <strong>xs</strong>，匹配任何事情，由一个小写字母或者下划线开始的标识符标识； <strong>~数据构造函数~</strong> 像 <code>Cons(x,xs) or Nil</code>这种 只匹配相对应格式的值。这些模式的元素们可以被任意嵌套 — Cons(x1, Cons( x2, Nil)) , Cons(y1, Cons(y2, Cons(y3, _))) 是合法的模式。</p>
<p>一个模式匹配一个目标(如果在模式中存在一个变量的分配)到 这个目标的子表达式 (使其结构上和目标相等的 子表达式 )，对于一个匹配的 case , 结果得到的表达式 接下来将会 在他的本地范围里面 access 这些变量的赋值 。(哇塞 英文好难直译啊 T.T)<br>总结一下这段话：<br>问题：什么决定了是否一个 模式 匹配一个表达式呢？<br>答案：一个模式 可能包含 ：常量，变量，数据构造器(怪翻译)。模式中的这些元素们可以互相组合嵌套。<br>尚未总结完毕</p>
<hr>
<p><strong>Scala 中的可变函数(Variadic functions in Scala)</strong><br><strong>List</strong> 对象中的 <strong>apply</strong> 函数 就是一个 <strong>~可变函数~</strong> 意味着它允许或者说接受 0 或者更多A类型的参数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>](as: <span class="type">A</span>*): <span class="type">List</span>[<span class="type">A</span>] = &#123;</div><div class="line">	<span class="keyword">if</span> (as.isEmpty) <span class="type">Nil</span></div><div class="line">	<span class="keyword">else</span> <span class="type">Cons</span>(as.head, apply(as.tail: _*))</div><div class="line">	实际：</div><div class="line">	<span class="keyword">if</span> (as.isEmpty) <span class="type">Nil</span></div><div class="line">	<span class="keyword">else</span> as.head::apply(as.tail: _*)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于 数据类型，这是一个常见的俗话去有一个可变的apply 方法 在伴生对象中方便的构建数据类型的实例。通过调用这个方法 apply 然后在伴生对象中替换他，我们可以和语法一样调用它，就像 List(1,2,3,4) 或者 List(“Hi”,”bye”), 和许多我们希望用逗号分开一样。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apply(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">res24: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">Cons</span>(<span class="number">1</span>,<span class="type">Cons</span>(<span class="number">2</span>,<span class="type">Cons</span>(<span class="number">3</span>,<span class="type">Cons</span>(<span class="number">4</span>,<span class="type">Cons</span>(<span class="number">5</span>,<span class="type">Nil</span>)))))</div><div class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">res31: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">apply(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"hello"</span>,<span class="string">"4"</span>)</div><div class="line">res49: <span class="type">List</span>[<span class="type">Any</span>] = <span class="type">Cons</span>(<span class="number">1</span>,<span class="type">Cons</span>(<span class="number">2</span>,<span class="type">Cons</span>(hello,<span class="type">Cons</span>(<span class="number">4</span>,<span class="type">Nil</span>))))</div></pre></td></tr></table></figure></p>
<p>如上图所示，调用 apply函数会把用逗号分开的值变成列表。</p>
<p>Variadic functions(可变函数)就是为 明确的创建和passing 一个元素序列( Seq of elements)提供一个语法糖🍬(<strong>syntactic sugar</strong>)。序列(Seq)是一个接口，在Scala库中，像 list, queue, vector 一样的一种数据结构。在 apply 里面 参数 as 将会被绑定成 Seq[A], 这个对象有着 head 方法 和 tail 方法。<br>特别的 _* 类型标注 允许我们 通过(pass) 一个 Seq 到一个可变成员方法。</p>
<hr>
<h2 id="3-3-Data-sharing-in-functional-data-structures-函数式数据结构中的数据共享"><a href="#3-3-Data-sharing-in-functional-data-structures-函数式数据结构中的数据共享" class="headerlink" title="3.3 Data sharing in functional data structures (函数式数据结构中的数据共享)"></a>3.3 Data sharing in functional data structures (函数式数据结构中的数据共享)</h2><p>当数据是不可变的时候，我们如何写函数，例如 从一个 List 中 add 或者 remove 元素？答案很简单，当我们添加一个元素1 到 一个列表的前头的时候，比如xs, 我们返回一个新的列表 Cons(1,xs)。 因为列表是不可改变的，我们不需要实际上的复制xs，只需要重新利用它，创建新的列表。我们叫它<strong>数据共享( Data sharing)</strong>。共享不可改变的数据常常使我们实现函数更加的高效；我们总可以返回不可改变的数据结构而不需要担心后面的数据修改我们的数据。并不需要悲观的通过复制不可变数据结构去避免<strong>修改</strong>和<strong>变形</strong>。</p>
<p>用同样的方式，从一个List <code>mylist = Cons(x,xs)</code>中移除头一个元素，我们只需要复制他的 <strong>tail</strong>就可以了。而 mylist 依旧存在和可用。我们说函数式数据结构是<strong>可持续的(persistent)</strong>， 意味着既有的参照关系绝对不会因为在数据结构上的操作而改变。</p>
<h3 id="数据共享的效率-The-efficiency-of-data-sharing"><a href="#数据共享的效率-The-efficiency-of-data-sharing" class="headerlink" title="数据共享的效率(The efficiency of data sharing)"></a>数据共享的效率(The efficiency of data sharing)</h3><p>数据分享的一个非常令人吃惊的例子就是 函数添加一个列表所有的元素到另一个列表的尾部：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span></span>[<span class="type">A</span>](a1: <span class="type">List</span>[<span class="type">A</span>], a2: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">List</span>[<span class="type">A</span>] = </div><div class="line">	a1 <span class="keyword">match</span>&#123;</div><div class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; a2</div><div class="line">		<span class="keyword">case</span> <span class="type">Cons</span>(h,t) =&gt; <span class="type">Cons</span>(h, append(t,a2))</div><div class="line">		实际：</div><div class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; a2</div><div class="line">		<span class="keyword">case</span> h::t =&gt; h::append(t,a2)</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>请注意这个定义仅仅是复制值 直到第一个链表的尾部，所以他的运行时间和内存利用是仅仅取决于 a1 的长度的。剩下的列表仅仅是指向 a2。如果我们要用两个<strong>数列(array)</strong>执行同样的操作的话，我们需要拷贝两个array 的所有的元素到输出上。所以在这种情况下，不可变链表是比数列更加高效的。</p>
<p>因为单链表的结构，任意时刻我们想要替换一个Cons的tail的时候，即使他是列表中的最后一个Cons，我们需要拷贝前面所有的Cons对象。写支持不同的高效操作的纯粹函数式数据结构需要我们找到一种聪明的方法去使用数据共享。现在我们并不准备自己亲自做所有的部分，我们可以很开心的使用Scala标准库，这里有定义好的<strong>纯粹函数式序列(pure functional sequence)</strong>的实现, <strong>~Vector~</strong> 。有着在常数时间下，随机的access(访问), updates, head,tail,init这些成员方法，常数时间下添加序列的头和尾。</p>
<hr>
<h3 id="提高高阶函数的类型推断"><a href="#提高高阶函数的类型推断" class="headerlink" title="提高高阶函数的类型推断"></a>提高高阶函数的类型推断</h3><p>高阶函数像 dropWhile 常常会被 匿名函数<strong>(anonymous functions)</strong> pass掉。看一个典型的例子：(dropWhile 函数式 当条件式子为假那么开始 不在看元素是否符合条件了，开始迭代序列 ,<br>即：符合条件的时候继续扫描下一个元素，直到条件不符合，返回剩下的元素的列表)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropWhile</span></span>[<span class="type">A</span>](as: <span class="type">List</span>[<span class="type">A</span>],f:<span class="type">A</span>=&gt;<span class="type">Boolean</span>):<span class="type">List</span>[<span class="type">A</span>] = as <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(h,t) <span class="keyword">if</span> (f(h)) =&gt; dropWhile(t,f)</div><div class="line">	<span class="keyword">case</span> e @ <span class="type">Cons</span>(h,t) =&gt; e</div><div class="line">	<span class="keyword">case</span> _ =&gt; <span class="type">Nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropWhile</span></span>[<span class="type">A</span>](l: <span class="type">List</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">A</span>] = l <span class="keyword">match</span> &#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(x,y) <span class="keyword">if</span>(f) =&gt; dropWhile(y,f)</div><div class="line">	<span class="keyword">case</span> _ =&gt; l</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设计思路：match的时候可以 case Cons(x,y) if(f) 满足条件的时候要同时满足条件。</p>
<p>当我们用 匿名函数 f 调用这个方法的时候，我们必须区分 f 的参数 这里叫 x：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line"><span class="keyword">val</span> ex1 = dropWhile(xs, (x: <span class="type">Int</span>) =&gt; x &lt; <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>这里如果不注释 x 的类型为 Int 的话会报错。<br>非常不幸的是我们需要规定 x 的类型是 Int。dropWhile的第一个参数是一个List[Int]， 所以函数的第二个参数必须符合Int。这是之前声明的时候定义好的。Scala 可以推断这个事实，如果我们把 dropwhile 归入到两个参数的链表中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropWhile</span></span>[<span class="type">A</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">A</span>] = as <span class="keyword">match</span>&#123;</div><div class="line">		<span class="keyword">case</span> <span class="type">Cons</span>(h,t) <span class="keyword">if</span> f(h) =&gt; dropWhile(t)(f)</div><div class="line">		<span class="keyword">case</span> _ =&gt; as</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用这个版本 dropWhile 函数的语法像 dropWhile(xs)(f)。其实就是啦，dropWhile(xs) 返回一个函数，我们利用 f 来作为参数 调用这个函数，其实就是dropWhile 被curry化了。这样grouping 参数的原因是为了帮助 类型推断。我们现在可以不用注释的使用dropWhile函数了:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line"><span class="keyword">val</span> ex1: dropWhile(xs)(x =&gt; x &lt; <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>这里的 x 就没有注释 x 的类型。<br>更普遍的，当一个函数定义里面包含着多种参数 group，类型信息从左到右的贯穿这些参数 groups。这里第一个参数group 固定了 parameterA 为Int，所以他右边的都是Int，x就不需要注释了。</p>
<p>我们通常将我们函数的参数 group 和 排序到 多重参数列表中来最大化 类型推论。</p>
<hr>
<h2 id="3-4-Recursion-over-lists-and-generalizing-to-higher-order-functions-通过链表的递归调用和概述高阶函数"><a href="#3-4-Recursion-over-lists-and-generalizing-to-higher-order-functions-通过链表的递归调用和概述高阶函数" class="headerlink" title="3.4 Recursion over lists and generalizing to higher-order functions (通过链表的递归调用和概述高阶函数)"></a>3.4 Recursion over lists and generalizing to higher-order functions (通过链表的递归调用和概述高阶函数)</h2><p>让我们重新看一下 sum 和 product 的实现。我们非常 轻盈的实现了 product 从而 没有包含了检查 “ 0.0 逻辑 “的问题。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(ints: <span class="type">List</span>[<span class="type">Int</span>]):<span class="type">Int</span> = ints <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span></div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(x,xs) =&gt; x + sum(xs)</div><div class="line">	改成 x::xs =&gt; x+sum(xs)</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(ds: <span class="type">List</span>[<span class="type">Double</span>]): <span class="type">Double</span> = ds <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">1.0</span></div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(x,xs) =&gt; x * product(xs)</div><div class="line">	改成：<span class="keyword">case</span> x::xs =&gt; x* product(xs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有没有注意到这两个函数是多么的相似，处理逻辑几乎一样。只是 处理数据的类型 一个是 Double 一个是 Int，撇开这个来看 不同点一个是 Nil 情况 返回值不同( 0 and 1.0)，操作符号不同(+ and * )。<br>无论何时，遇到这种重叠的情况，你都想把这种重叠 抽象出来，把子表达式拽出来作为参数。如果一个子表达式关联任何本地变量( + 关联 本地变量 x 和 xs ，product也一样)，把这个子表达式 放入采用这些变量作为参数的函数中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], z: <span class="type">B</span>)(f: (<span class="type">A</span>,<span class="type">B</span>) =&gt; <span class="type">B</span>) :<span class="type">B</span> =&#123;</div><div class="line">	as <span class="keyword">match</span>&#123;</div><div class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; z</div><div class="line">		<span class="keyword">case</span> <span class="type">Cons</span>(x,xs) =&gt; f(x, foldRight(xs, z)(f))</div><div class="line">		改成：</div><div class="line">		<span class="keyword">case</span> x::xs =&gt; f(x,foldRight(xs,z)(f))</div><div class="line">	&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span></span>(ns: <span class="type">List</span>[int]) = &#123;</div><div class="line">	foldRight(ns, <span class="number">0</span>)((x,y) =&gt; x + y)	</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product2</span></span>(ns:<span class="type">List</span>[<span class="type">Double</span>]) = &#123;</div><div class="line">	foldRight(ns,d <span class="number">1.0</span>)(_ * _)	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>把 f 放入他自己的参数 group 在 as 和 z 之后，让 参数推断决定f 输入类型。</li>
<li><em> * </em> 是 (x, y) =&gt; x * y 更简明的一种注释。</li>
</ul>
<p>你看我们在编程的时候很多方法都有共同点，他们可能都有一个可以归纳的核心逻辑，然后把这个核心逻辑抽离出来就变成foldright了。</p>
<p>foldRight (右折叠)没有指定任何一种元素的参数类型，我们发现 当概括/一般化之后，返回值并不一定是元素一个类型的。一种描述 foldRight 做了什么就是: 他替换了List 的 构造器，用 z 和 f 替换了 Nil 和 Cons ：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="type">Cons</span>(<span class="number">1</span>, <span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Nil</span>))</div><div class="line">f   (<span class="number">1</span>, f   (<span class="number">2</span>, z   ))</div><div class="line"></div><div class="line">foldRight(<span class="type">Cons</span>(<span class="number">1</span>, <span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Nil</span>))), <span class="number">0</span>) ((x,y) =&gt; x+y )</div><div class="line"><span class="number">1</span> +	foldRight(<span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Nil</span>)), <span class="number">0</span>) ((x,y) =&gt; x+y )</div><div class="line"><span class="number">1</span> +	(<span class="number">2</span> +	foldRight(<span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Nil</span>), <span class="number">0</span>) ((x,y) =&gt; x+y ))</div><div class="line"><span class="number">1</span> +   (<span class="number">2</span> +  	(<span class="number">3</span> + (foldRight(<span class="type">Cons</span>(<span class="type">Nil</span>, <span class="number">0</span>) ((x,y) =&gt; x+y ))))</div><div class="line"><span class="number">1</span> + 	(<span class="number">2</span> +	(<span class="number">3</span> + (<span class="number">0</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>foldRight 遍历所有的路径，直到list 末尾。<br>为什么说foldRight 可能会有 栈溢出，因为他是 一层一层的迭代，在扫描到最后一个数之前所有的数都要留着，从最后一个数开始计算然后在往回一层一层计算，所以会有栈溢出的可能性。</p>
<p>再分析一下foldRight<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], z: <span class="type">B</span>)(f: (<span class="type">A</span>,<span class="type">B</span>) =&gt; <span class="type">B</span>) :<span class="type">B</span> =</div><div class="line">	as <span class="keyword">match</span>&#123;</div><div class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; z</div><div class="line">		<span class="keyword">case</span> x::xs =&gt; f(x, foldRight(xs, z)(f))</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>两个参数()(), 所以前面foldRight[A][B], 看参数里面(List[A],z:B)这个没啥说的<br>(f: (A,B)=&gt;B ) 这个指的是 里面的参数是一个函数：参数为A 和 B，A为List中的元素类型，B就是z的类型，最后得出结果为类型B。然后里面的body也是很棒，返回 Cons(x,xs) =&gt; f( x, foldRight(xs,z)(f) ) 返回的是列表的第一个元素和后面的迭代的值经过 f 操作。</p>
<p>下面看看<strong>foldLeft</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>],z:<span class="type">B</span>)(f :(<span class="type">B</span>,<span class="type">A</span>) =&gt; <span class="type">B</span>):<span class="type">B</span> =as <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(h,t) =&gt; foldLeft(t,f(z,h))(f)</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; z</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">Cons</span>(<span class="number">1</span>,<span class="type">Cons</span>(<span class="number">2</span>,<span class="type">Cons</span>(<span class="number">3</span>,<span class="type">Nil</span>)))</div><div class="line">f(<span class="number">3</span>,   f(<span class="number">2</span>,   f(<span class="number">1</span>,   z)))</div><div class="line"></div><div class="line">foldLeft(<span class="type">Cons</span>(<span class="number">1</span>, <span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Nil</span>))), <span class="number">0</span>) ((x,y) =&gt; x+y )</div><div class="line">foldLeft(<span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Nil</span>)), <span class="number">1</span>+<span class="number">0</span>) ((x,y) =&gt; x+y )</div><div class="line">foldLeft(<span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Nil</span>), <span class="number">2</span>+<span class="number">1</span>+<span class="number">0</span>) ((x,y) =&gt; x+y ))</div><div class="line">foldLeft(<span class="type">Nil</span>, <span class="number">3</span>+<span class="number">2</span>+<span class="number">1</span>) ((x,y) =&gt; x+y ))))</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>你在看看这个左折叠的 z 的值是每次迭代都会更新一次的，然后每次的这个更新后的值在带入下一个函数里面，所以这个就不会有栈溢出的问题。<br>很神奇哦，就是明明是顺序运算但是却 写成这个样子。。<br>在这里他用List 的第一个的元素和参数z 进行 f 运算然后放入第二次迭代的参数进行第二次迭代。所以可以看做是一边运算一遍进行迭代。而foldright 则是一直迭代到底然后在返回来。<br>两者有啥区别？？</p>
<h3 id="考点！！-List-reverse-教授好像说会考-List-的-Reverse"><a href="#考点！！-List-reverse-教授好像说会考-List-的-Reverse" class="headerlink" title="(考点！！)List.reverse 教授好像说会考 List 的 Reverse ~~"></a>(考点！！)List.reverse 教授好像说会考 List 的 Reverse ~~</h3><p>分别利用 dropLeft 和 dropRight 来编写 reverse函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>[<span class="type">A</span>](as: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">List</span>[<span class="type">A</span>] = &#123;</div><div class="line">	foldLeft(as, <span class="type">List</span>.empty[<span class="type">A</span>])((acc,a) =&gt; <span class="type">Cons</span>(a,acc))</div><div class="line">或者</div><div class="line">	foldLeft(as, <span class="type">Nil</span>:<span class="type">List</span>[<span class="type">A</span>])((acc,a)=&gt;<span class="type">Cons</span>(a,acc))</div><div class="line">实际：</div><div class="line">	foldLeft(as,<span class="type">Nil</span>:<span class="type">List</span>[<span class="type">A</span>])((a,acc)=&gt; acc::a )</div><div class="line">或者</div><div class="line">	foldLeft(as,<span class="type">Nil</span>:<span class="type">List</span>[<span class="type">A</span>])((acc,b) =&gt; append(b::<span class="type">Nil</span>,acc))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>[<span class="type">A</span>](as:<span class="type">List</span>[<span class="type">A</span>]):<span class="type">List</span>[<span class="type">A</span>]= &#123;</div><div class="line">	foldRight(as,<span class="type">List</span>.empty[<span class="type">A</span>])((a,b)=&gt;append(b,<span class="type">Cons</span>(a,<span class="type">Nil</span>)))</div><div class="line">	实际：</div><div class="line">	foldRight(as,<span class="type">Nil</span>:<span class="type">List</span>[<span class="type">A</span>])((a,b)=&gt;append(b,a::<span class="type">Nil</span>))</div><div class="line">	或者：</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拆开 foldLeft和foldRight 版本的reverse<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">reverse-foldLeft(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)) =</div><div class="line">foldLeft(list(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="type">Nil</span>)((a,acc)=&gt; acc::a)=</div><div class="line">								(<span class="type">Nil</span>,<span class="number">1</span>)=&gt; <span class="number">1</span>::<span class="type">Nil</span> </div><div class="line">foldLeft(<span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="number">1</span>::<span class="type">Nil</span>) =  </div><div class="line">								(<span class="number">1</span>::<span class="type">Nil</span>,<span class="number">2</span>) =&gt; <span class="number">2</span>::<span class="number">1</span>::<span class="type">Nil</span> </div><div class="line">foldLeft(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="number">2</span>::<span class="number">1</span>::<span class="type">Nil</span>) = </div><div class="line">								(<span class="number">2</span>::<span class="number">1</span>::<span class="type">Nil</span>,<span class="number">3</span>) =&gt; <span class="number">3</span>::<span class="number">2</span>::<span class="number">1</span>::<span class="type">Nil</span></div><div class="line">...</div><div class="line"><span class="number">5</span>::<span class="number">4</span>::<span class="number">3</span>::<span class="number">2</span>::<span class="number">1</span>::<span class="type">Nil</span></div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">reverse-foldRight(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) = </div><div class="line">foldRight(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="type">Nil</span>)((a,b)=&gt;append(b,a::<span class="type">Nil</span>))</div><div class="line">append(floldRight(<span class="number">2</span>::<span class="number">3</span>::<span class="type">Nil</span>,<span class="type">Nil</span>),<span class="number">1</span>::<span class="type">Nil</span>)</div><div class="line">append(append(foldRight(<span class="number">3</span>::<span class="type">Nil</span>,<span class="type">Nil</span>),<span class="number">2</span>::<span class="type">Nil</span>),<span class="number">1</span>::<span class="type">Nil</span>)</div><div class="line">append(append(append(<span class="type">Nil</span>,<span class="number">3</span>::<span class="type">Nil</span>),<span class="number">2</span>::<span class="type">Nil</span>),<span class="number">1</span>::<span class="type">Nil</span>)</div><div class="line"><span class="number">3</span>::<span class="number">2</span>::<span class="number">1</span>::<span class="type">Nil</span></div></pre></td></tr></table></figure>
<p>思路：<br>利用foldRight和foldLeft的 原理和性质。<br>Left呢就是利用第一个元素和初始值进行计算然后带入到第二个元素计算中的初始值中，迭代计算。<br>Right呢就是 先不进行运算，先迭代到最底层然后从最后一个元素和初始值进行运算在返回来的这么一个过程。</p>
<h3 id="匿名函数的下划线注释-Underscore-notation-for-anonymous-functions"><a href="#匿名函数的下划线注释-Underscore-notation-for-anonymous-functions" class="headerlink" title="匿名函数的下划线注释(Underscore notation for anonymous functions)"></a>匿名函数的下划线注释(Underscore notation for anonymous functions)</h3><p>匿名函数(x,y) =&gt; x+ y 可以写成 <em> + </em> ，在 x 和 y 的类型可以被Scala 推测出的环境下。 这个非常实用，在case里面速写的时候，条件：在函数body中 参数只被提到一次的时候。在匿名函数中的每个下划线 像 <em> + </em> 引入了一种新的函数参数和参照它。参数以 从左至右的顺序被介绍。例如 x, y都只用了一次，顺序是 x, y 所以 可以 <em>, </em>来替代<br>下面有一些例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_ + _         (x, y)	=&gt; x + y</div><div class="line">_ * 2         x      	=&gt; x * 2</div><div class="line">_.head        xs     	=&gt; xs.head</div><div class="line">_ drop _     	(xs, n) =&gt; xs.drop(n) </div><div class="line">_.drop(_)也可以</div></pre></td></tr></table></figure>
<p>请明智的使用这个语法。在表达式中这个语法的意义像 foo(<em> , g(List(</em> + 1), _ ))可能不会很清楚。关于这些 基于下划线的 匿名函数的 scope 有严格的 规则，在Scala 细则里面，除非你必须使用它，我们建议使用普通的参数命名规范。</p>
<h3 id="考点！！-List-flatten"><a href="#考点！！-List-flatten" class="headerlink" title="(考点！！)List.flatten"></a>(考点！！)List.flatten</h3><p>flatten函数就是把List(List(1,2,3), List(“a”,”b”,”c”),List(a,b,c))摊开了变成一个LIst(1,2,3,”a”,”b”,”c”,a,b,c)……<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">A</span>](ffa: <span class="type">List</span>[<span class="type">List</span>[<span class="type">A</span>]]):<span class="type">List</span>[<span class="type">A</span>] = ffa <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(h,t) =&gt; append(h, flatten(t))</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">A</span>](ffa: <span class="type">List</span>[<span class="type">List</span>[<span class="type">A</span>]]):<span class="type">List</span>[<span class="type">A</span>] =&#123;</div><div class="line">	foldLeft(ffa,<span class="type">List</span>.empty[<span class="type">A</span>])(append(_,_))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="考点！！-List-join"><a href="#考点！！-List-join" class="headerlink" title="(考点！！)List.join"></a>(考点！！)List.join</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](ffa:<span class="type">List</span>[<span class="type">List</span>[<span class="type">A</span>]]):<span class="type">List</span>[<span class="type">A</span>] = &#123;</div><div class="line">	foldRight(ffa,<span class="type">List</span>.empty[<span class="type">A</span>])(append(_,_))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="考点！！-Map"><a href="#考点！！-Map" class="headerlink" title="(考点！！)Map"></a>(考点！！)Map</h3><p>引子：想要在list 中的每个元素都➕1 怎么写？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">incOne</span></span>(as:<span class="type">List</span>[<span class="type">Int</span>]):<span class="type">List</span>[<span class="type">Int</span>] = as <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> h::t =&gt; h+<span class="number">1</span>::incOne(t)</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>implicit class 是啥？</p>
<p>List[Double] -&gt; List[String]<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleToString</span></span>(as:<span class="type">List</span>[<span class="type">Double</span>]):<span class="type">List</span>[<span class="type">String</span>] = as <span class="keyword">match</span>&#123;</div><div class="line">	<span class="keyword">case</span> h::t =&gt; h.toString::doubleToString(t)</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仔细观察这两个函数 发没发现 共同点：他们都没有改变原有List 的结构，只是单纯的改变了List 中 每一个元素的 值或者属性。这个跟foldright或者foldleft不太一样，fold系列改变了 List 的结构，拆开表格之后进行了这那那这的操作。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>,<span class="type">B</span>](fa:<span class="type">List</span>[<span class="type">A</span>])(f:<span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = fa <span class="keyword">match</span> &#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(h,t) =&gt; f(h)::map(t)(f)</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f:<span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = </div><div class="line">foldRight(as,<span class="type">List</span>.empty[<span class="type">B</span>])((a,acc)=&gt; f(a)::acc )</div><div class="line">或者：</div><div class="line">foldLeft(as,<span class="type">Nil</span>:<span class="type">List</span>[<span class="type">B</span>])((acc,a)=&gt; append(acc,f(a)::<span class="type">Nil</span>) )</div></pre></td></tr></table></figure>
<p>这里再说一嘴，foldRight 和 foldLeft是 scala里面 很重要的两个函数，它俩啥都能做。会考哦~~</p>
<p>那究竟什么是 map ，而map 为什么在scala中这么重要呢？<br>map 有两个输入，一个是 List 一个是 函数 f ， 他把list 中的每一个元素进行了f函数的处理之后 返回 这个原来的List。但是要说的是，原有的List 大结构可能不变，但是多少会变，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; map(List(1,2,3))((x=&gt;x match&#123;case 3 =&gt; List(&apos;a&apos;,&apos;b&apos;) case _ =&gt; x*2&#125;))</div><div class="line">res57: List[Any] = List(2, 4, List(a, b))</div></pre></td></tr></table></figure></p>
<p>这个例子输入的List类型是List[Int] 但是出来之后变成List[Any]了，只是结构还是三个元素这个不变而已。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo</span></span>&#123;</div><div class="line">	<span class="keyword">val</span> as = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">	<span class="keyword">val</span> bs = <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>&#123;</div><div class="line">		a &lt;- as</div><div class="line">		b &lt;- bs</div><div class="line">	&#125;<span class="keyword">yield</span> (a,b)</div><div class="line">buxing 必须有 flatmap 和 map 类型</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>yield</code>是什么呢？yield 是跟在for 循环后面常常使用的一个关键字，然后他会把for中的 项记载下来在循环结束之后返回，类型和输入的类型是一样的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = as <span class="keyword">match</span> &#123;</div><div class="line">	<span class="keyword">case</span> <span class="type">Cons</span>(h,t) =&gt; append(f(h),flatMap(t)(f))</div><div class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span> </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap2</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] =</div><div class="line">	foldRight(as,<span class="type">List</span>.empty[<span class="type">B</span>])((a,acc)=&gt;append(f(a),acc)) </div><div class="line">	或者：</div><div class="line">	foldLeft(as,<span class="type">List</span>.empty[<span class="type">B</span>])((acc,a)=&gt;append(acc,f(a)))</div></pre></td></tr></table></figure>
<p>其实哦，flatMap 和 Map 基本一样，唯一的不一样就是 它把Map 给 flatten了，也就是把里面的嵌套List结构都打散，变成了一个List。</p>
<p>在试图用 foldRight 和 foldLeft重写的时候 你要知道的是，这里面类型最最重要。<br><strong>思路：</strong></p>
<ul>
<li>首先 目标是：把元素里的每个元素都经过 f 函数变换，然后用append函数 将 List 变为一个，而没有嵌套List结构。所以 foldRight 和 foldLeft函数都符合范围。</li>
<li>其次我们思考格式匹配：<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap2</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] =</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], z: <span class="type">B</span>)(f: (<span class="type">A</span>,<span class="type">B</span>) =&gt; <span class="type">B</span>) :<span class="type">B</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>],z:<span class="type">B</span>)(f :(<span class="type">B</span>,<span class="type">A</span>) =&gt; <span class="type">B</span>):<span class="type">B</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为我们要使用这两个函数，那么必须知道这两个函数的 参数类型和返回值类型，哇塞，能想到这个就已经算是具备一定编程思想的银了哎。<br>那不论foldRight还是foldLeft 第一个参数是不需要思考的 一样的，都是as，而且初始值 是 Nil  也没有错。 所以 ：<br><code>foldRight(as,List.empty[B])</code> 或者：<br><code>foldLeft(as,List.empty[B])</code><br>然后，我们思考 f 操作，foldRight的 f : (A,B) =&gt;B 那么我们希望append(f(第一个元素），后面的List ) 是结果变成：append(1,append(2,append(3,Nil)))这种。所以要<br><code>foldRight(as,List.empty[B])((a,acc)=&gt;append(f(a),acc))</code><br>接下来思考 foldLeft的 f 操作 : f : (B,A)=&gt;B 那么就是 Nil 作为 f 的第一参数，和 f (List 中的 第一个元素) 做 append操作，<br><code>foldLeft(as,List.empty[B])((acc,a)=&gt;append(acc,f(a)))</code><br>但是要保持元素和Nil 的顺序，但是append 有着这么一个特性，append(Nil,a2) = a2,所以这里就算 append (Nil, f(a))也没有关系，还是f(a)，<br>但是编程的时候 想的好复杂，left right 的内部逻辑还思考了很多，但是其实不需要思考，调用函数的时候，不许要考虑调用的函数的内部逻辑，只要参数类型对了，你选择的函数对了，就不要考虑太多了。</p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f:<span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = </div><div class="line">	foldRight(as,<span class="type">List</span>.empty[<span class="type">B</span>])((a,acc)=&gt; f(a)::acc )</div><div class="line">	或者：</div><div class="line">	foldLeft(as,<span class="type">Nil</span>:<span class="type">List</span>[<span class="type">B</span>])((acc,a)=&gt; append(acc,f(a)::<span class="type">Nil</span>) )</div><div class="line">-----------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap2</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] =</div><div class="line">	foldRight(as,<span class="type">List</span>.empty[<span class="type">B</span>])((a,acc)=&gt;append(f(a),acc)) </div><div class="line">	或者：</div><div class="line">	foldLeft(as,<span class="type">List</span>.empty[<span class="type">B</span>])((acc,a)=&gt;append(acc,f(a)))</div></pre></td></tr></table></figure>
<p>在利用 foldRight 和 foldLeft 编写 map 和 flatMap的时候又多了一些感悟，这种感悟是一种感觉，不是简单地看规则就有的感觉。</p>
<h3 id="f-操作"><a href="#f-操作" class="headerlink" title="f 操作"></a>f 操作</h3><p>先看 map 和 flatMap的 f 操作，map是 A=&gt;B 也就是 list中的A类型元素经过 f 操作 生成 B类型的结果，注意这里不是生成了List 类型 而是B类型。<br>而flatMap的 f 操作生成的是 A=&gt;List[B] 元素类型为B的List类型，他们两个产物不太一样。</p>
<p>这一不同直接影响到了 body 的编写，因为 foldRight 和 foldLeft 要求的f 操作的类型分别是 (A,B)=&gt;B 和 (B,A)=&gt;B<br>那么看好了，<br>map：        <code>foldRight(as,List.empty[B])((a,acc)=&gt; f(a)::acc )</code><br>flatMap： <code>foldRight(as,List.empty[B])((a,acc)=&gt;append(f(a),acc))</code><br>这里面 (a,acc) 分别代表的是 (List中的每一个元素(A类型), Nil 和 迭代返回的B类型的 结果)。所以(a,acc)=&gt; f(a)::acc   的 类型检测就是 (A,B)=&gt; B::B 而从<code>List.empty[B]或者Nil:List[B]</code>这段代码系统就可以检测到 foldRight 的B类型是 List[B]，所以 B::B 返回一个List[B] 类型没啥问题，或者 B::List[B] 这种也是 返回 LIst[B]那么这有回到了第一节课的时候，有点脑子混乱，B类型和List[B]类性有点乱。而flatMap则不可以直接 f(a)::acc而是必须 append(f(a),acc)因为多了flaten的过程。</p>
<p>map:   <code>foldLeft(as,Nil:List[B])((acc,a)=&gt; append(acc,f(a)::Nil) )</code><br>flatMap: <code>foldLeft(as,List.empty[B])((acc,a)=&gt;append(acc,f(a)))</code><br>foldLeft的 f 操作的类型是 (B,A)=&gt;B , 所以 后面的那个a 才是 list中的元素。所以要 f(a)。 然后为什么要 f(a)::Nil 因为append要求 添加List[A]和 List[B]。而 f(a)返回的是 B类型的参数，必须加上NIl 编程 list[B]类型的才可以运行append。<br>要切记的是 Cons(List(a),List(b)) 和 append(List(a),List(b))是不一样的哦。</p>
<hr>
<p>莫纳德 拥有 flatmap 和map 。<br>那什么是 莫纳德？</p>
<p>学C++ 和 C 学 指针的时候最难<br>函数式方法中 莫纳德最难。。。</p>
<p>berrito？？？</p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</div><div class="line">	flatten(map(as)(f)) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>flatmap就是先mapping 然后在flatting ~~</p>
<hr>
<h3 id="List-pure"><a href="#List-pure" class="headerlink" title="List.pure"></a><strong>List.pure</strong></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pure</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">List</span>[<span class="type">A</span>] = <span class="type">List</span>(a)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>[<span class="type">A</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">Boolean</span>):<span class="type">List</span>[<span class="type">A</span>] = &#123;</div><div class="line">	flatMap(as)(a =&gt; <span class="keyword">if</span>(f(a)) <span class="type">List</span>(a) <span class="keyword">else</span> <span class="type">Nil</span>)</div><div class="line">	flatMap(as)(a =&gt; <span class="keyword">if</span>(f(a)) pure(a) <span class="keyword">else</span> <span class="type">Nil</span>)</div><div class="line">	因为这里用的是参数 <span class="type">LIst</span> 以后的话不一定参数类型就是<span class="type">LIst</span>类型的。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="3-5-Trees-树"><a href="#3-5-Trees-树" class="headerlink" title="3.5 Trees (树)"></a>3.5 Trees (树)</h2><h2 id="3-6-Summary-总结"><a href="#3-6-Summary-总结" class="headerlink" title="3.6 Summary(总结)"></a>3.6 Summary(总结)</h2>
      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.png" alt="SweatBuffer wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫描二维码</div>
</div>


      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Functional-programming/" rel="tag"># Functional programming</a>
          
            <a href="/tags/Scala/" rel="tag"># Scala</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/24/title: Functional programming in Scala(一)/" rel="next" title="Functional programming in Scala(一)">
                <i class="fa fa-chevron-left"></i> Functional programming in Scala(一)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/04/28/title: Functional programming in Scala(三)/"
           data-title="Functional programming in Scala(三)" data-url="http://www.sweatbuffer.com/2017/04/28/title: Functional programming in Scala(三)/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="SweatBuffer" />
          <p class="site-author-name" itemprop="name">SweatBuffer</p>
          <p class="site-description motion-element" itemprop="description">孤单又灿烂的向日葵</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter3-Functional-data-structures-函数式数据结构"><span class="nav-number">1.</span> <span class="nav-text">Chapter3 Functional data structures (函数式数据结构)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Defining-functional-data-structures-定义-函数式数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">3.1 Defining functional data structures (定义 函数式数据结构)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala-Convariance-and-Contravariance-逆变与协变"><span class="nav-number">1.1.1.</span> <span class="nav-text">Scala Convariance and Contravariance(逆变与协变)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Pattern-matching-模式匹配"><span class="nav-number">1.2.</span> <span class="nav-text">3.2 Pattern matching (模式匹配)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Data-sharing-in-functional-data-structures-函数式数据结构中的数据共享"><span class="nav-number">1.3.</span> <span class="nav-text">3.3 Data sharing in functional data structures (函数式数据结构中的数据共享)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据共享的效率-The-efficiency-of-data-sharing"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据共享的效率(The efficiency of data sharing)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提高高阶函数的类型推断"><span class="nav-number">1.3.2.</span> <span class="nav-text">提高高阶函数的类型推断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Recursion-over-lists-and-generalizing-to-higher-order-functions-通过链表的递归调用和概述高阶函数"><span class="nav-number">1.4.</span> <span class="nav-text">3.4 Recursion over lists and generalizing to higher-order functions (通过链表的递归调用和概述高阶函数)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#考点！！-List-reverse-教授好像说会考-List-的-Reverse"><span class="nav-number">1.4.1.</span> <span class="nav-text">(考点！！)List.reverse 教授好像说会考 List 的 Reverse ~~</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数的下划线注释-Underscore-notation-for-anonymous-functions"><span class="nav-number">1.4.2.</span> <span class="nav-text">匿名函数的下划线注释(Underscore notation for anonymous functions)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考点！！-List-flatten"><span class="nav-number">1.4.3.</span> <span class="nav-text">(考点！！)List.flatten</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考点！！-List-join"><span class="nav-number">1.4.4.</span> <span class="nav-text">(考点！！)List.join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考点！！-Map"><span class="nav-number">1.4.5.</span> <span class="nav-text">(考点！！)Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-操作"><span class="nav-number">1.4.6.</span> <span class="nav-text">f 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-pure"><span class="nav-number">1.4.7.</span> <span class="nav-text">List.pure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-Trees-树"><span class="nav-number">1.5.</span> <span class="nav-text">3.5 Trees (树)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-Summary-总结"><span class="nav-number">1.6.</span> <span class="nav-text">3.6 Summary(总结)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SweatBuffer</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jinwenhui93"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
